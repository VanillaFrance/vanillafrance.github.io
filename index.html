<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driven Pendulum Simulation + Continuous Phase Diagram</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { color: #333; margin-bottom: 10px; }
        
        /* Layout for the main container */
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
            gap: 20px;
            max-width: 1200px;
            justify-content: center;
        }

        /* Container for the two canvases */
        .canvas-group {
            display: flex;
            gap: 10px;
        }

        /* Styling the canvases */
        canvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fafafa;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.95rem;
        }
        input[type=range] { width: 100%; cursor: pointer; }
        
        .value-display {
            font-size: 0.85em;
            color: #007bff;
            text-align: right;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            flex: 1;
            min-width: 80px;
        }
        button:hover { background-color: #0056b3; }
        button:active { transform: scale(0.98); }
        
        button.reset { background-color: #6c757d; }
        button.reset:hover { background-color: #545b62; }
        
        .scenario-btn { background-color: #28a745; }
        .scenario-btn:hover { background-color: #1e7e34; }

        .plot-label {
            text-align: center;
            font-weight: bold;
            color: #444;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

    </style>
</head>
<body>

    <h1>Driven Pendulum & Phase Space</h1>

    <div class="container">
        
        <div class="canvas-group">
            <div>
                <div class="plot-label">Physical Motion</div>
                <canvas id="simCanvas" width="400" height="400"></canvas>
            </div>
            <div>
                <div class="plot-label">Phase Diagram ($\dot{\theta}$ vs $\theta$)</div>
                <canvas id="phaseCanvas" width="400" height="400"></canvas>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="w0">Natural Freq ($\omega_0$)</label>
                <input type="range" id="w0" min="1" max="10" step="0.1" value="6.28">
                <div class="value-display" id="val-w0">6.28 rad/s</div>
            </div>
            <div class="control-group">
                <label for="w">Drive Freq ($\omega$)</label>
                <input type="range" id="w" min="0" max="250" step="1" value="6.28">
                <div class="value-display" id="val-w">6.28 rad/s</div>
            </div>
            <div class="control-group">
                <label for="a">Norm. Amplitude ($a$)</label>
                <input type="range" id="a" min="0" max="1.5" step="0.01" value="0.1">
                <div class="value-display" id="val-a">0.1</div>
            </div>
            
            <div class="control-group" style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 5px;">
                 <label>Scenarios:</label>
                 <div class="buttons">
                    <button class="scenario-btn" onclick="setResonance()">Resonance</button>
                    <button class="scenario-btn" onclick="setKapitza()">Kapitza (Inverted)</button>
                    <button class="scenario-btn" onclick="setChaos()">Chaos</button>
                 </div>
            </div>

             <div class="buttons" style="margin-top: auto; border-top: 1px solid #ddd; padding-top: 10px;">
                <button id="playPauseBtn">Pause</button>
                <button id="clearPhaseBtn" style="background-color: #17a2b8;">Clear Trace</button>
            </div>
            <div class="buttons">
                <button class="reset" onclick="resetSim(0.1)">Reset (Bottom)</button>
                <button class="reset" onclick="resetSim(Math.PI - 0.05)">Reset (Top)</button>
            </div>
        </div>
    </div>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script>
        // --- Canvas Setup ---
        const simCanvas = document.getElementById('simCanvas');
        const simCtx = simCanvas.getContext('2d');
        
        const phaseCanvas = document.getElementById('phaseCanvas');
        const phaseCtx = phaseCanvas.getContext('2d');

        // --- Physics State ---
        let state = {
            theta: 0.1,  // Angle (radians)
            omega: 0,    // Angular velocity (rad/s)
            t: 0         // Time (s)
        };
        
        // Store previous phase point for continuous line drawing
        let lastPhasePoint = null;

        // --- Parameters ---
        let params = {
            w0: 6.28,    // Natural frequency
            w: 6.28,     // Drive frequency
            a: 0.1,      // Normalized drive amplitude
            dt: 0.005    // Simulation time step
        };

        // --- Visualization Constants ---
        const L_pix = 130; // Length of pendulum in pixels
        const simOriginX = simCanvas.width / 2;
        const simOriginY = simCanvas.height / 2;
        
        // Phase plot scales
        const phaseScaleX = 350 / (2 * Math.PI); // Map -PI..PI to canvas width
        const phaseScaleY = 8; // Zoom for Omega
        const phaseOriginX = phaseCanvas.width / 2;
        const phaseOriginY = phaseCanvas.height / 2;

        let isRunning = true;

        // --- Physics Engine (RK4) ---
        function getDerivatives(curState, t) {
            const theta = curState.theta;
            const omega = curState.omega;
            
            const theta_dot = omega;
            // Equation: theta_ddot = sin(theta) * (a * w^2 * cos(wt) - w0^2)
            const omega_dot = Math.sin(theta) * (params.a * params.w * params.w * Math.cos(params.w * t) - params.w0 * params.w0);
            
            return { theta_dot, omega_dot };
        }

        function rk4Step() {
            let s1 = state;
            let k1 = getDerivatives(s1, state.t);

            let s2 = { theta: state.theta + k1.theta_dot * params.dt / 2, omega: state.omega + k1.omega_dot * params.dt / 2 };
            let k2 = getDerivatives(s2, state.t + params.dt / 2);

            let s3 = { theta: state.theta + k2.theta_dot * params.dt / 2, omega: state.omega + k2.omega_dot * params.dt / 2 };
            let k3 = getDerivatives(s3, state.t + params.dt / 2);

            let s4 = { theta: state.theta + k3.theta_dot * params.dt, omega: state.omega + k3.omega_dot * params.dt };
            let k4 = getDerivatives(s4, state.t + params.dt);

            state.theta += (params.dt / 6) * (k1.theta_dot + 2*k2.theta_dot + 2*k3.theta_dot + k4.theta_dot);
            state.omega += (params.dt / 6) * (k1.omega_dot + 2*k2.omega_dot + 2*k3.omega_dot + k4.omega_dot);
            state.t += params.dt;
        }

        // --- Drawing: Physical Simulation ---
        function drawSim() {
            simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);

            // Drive motion
            const A_pix = params.a * L_pix;
            const supportY = simOriginY - A_pix * Math.cos(params.w * state.t);
            const supportX = simOriginX;

            const bobX = supportX + L_pix * Math.sin(state.theta);
            const bobY = supportY + L_pix * Math.cos(state.theta);

            // Axis
            simCtx.beginPath();
            simCtx.moveTo(simOriginX, 20);
            simCtx.lineTo(simOriginX, simCanvas.height - 20);
            simCtx.strokeStyle = '#e0e0e0';
            simCtx.setLineDash([5, 5]);
            simCtx.stroke();
            simCtx.setLineDash([]);

            // String
            simCtx.beginPath();
            simCtx.moveTo(supportX, supportY);
            simCtx.lineTo(bobX, bobY);
            simCtx.strokeStyle = '#333';
            simCtx.lineWidth = 3;
            simCtx.stroke();

            // Support
            simCtx.beginPath();
            simCtx.arc(supportX, supportY, 6, 0, 2 * Math.PI);
            simCtx.fillStyle = '#d9534f';
            simCtx.fill();

            // Bob
            simCtx.beginPath();
            simCtx.arc(bobX, bobY, 15, 0, 2 * Math.PI);
            const speed = Math.abs(state.omega);
            const colorVal = Math.max(255 - speed*10, 50);
            simCtx.fillStyle = `rgb(50, 50, ${colorVal})`; 
            simCtx.fill();
            simCtx.strokeStyle = '#222';
            simCtx.stroke();

            // Info
            simCtx.fillStyle = '#555';
            simCtx.font = '12px monospace';
            simCtx.fillText(`t: ${state.t.toFixed(2)}s`, 10, 20);
        }

        // --- Drawing: Phase Diagram (Continuous) ---
        function drawPhase() {
            // Slower fade effect for continuous trails (0.02 opacity)
            phaseCtx.fillStyle = 'rgba(250, 250, 250, 0.02)';
            phaseCtx.fillRect(0, 0, phaseCanvas.width, phaseCanvas.height);

            // Draw Axes (faint layer on top to keep them visible)
            phaseCtx.beginPath();
            phaseCtx.strokeStyle = 'rgba(220, 220, 220, 0.1)';
            phaseCtx.lineWidth = 1;
            phaseCtx.moveTo(0, phaseOriginY); phaseCtx.lineTo(phaseCanvas.width, phaseOriginY); // X-axis
            phaseCtx.moveTo(phaseOriginX, 0); phaseCtx.lineTo(phaseOriginX, phaseCanvas.height); // Y-axis
            phaseCtx.stroke();

            // Normalize Theta to [-PI, PI] for the plot
            let wrappedTheta = state.theta % (2 * Math.PI);
            if (wrappedTheta > Math.PI) wrappedTheta -= 2 * Math.PI;
            if (wrappedTheta < -Math.PI) wrappedTheta += 2 * Math.PI;

            // Map to pixels
            const px = phaseOriginX + wrappedTheta * phaseScaleX; // X is Theta
            const py = phaseOriginY - state.omega * phaseScaleY;   // Y is Omega (up is positive)

            // Draw continuous line if we have a previous point
            if (lastPhasePoint) {
                // Calculate distance squared to detect wrapping jumps
                const dx = px - lastPhasePoint.x;
                const dy = py - lastPhasePoint.y;
                const distSq = dx*dx + dy*dy;

                // Only draw line if distance is reasonable (e.g., not wrapping across screen)
                // Threshold is heuristic: approx 1/4 canvas width squared
                if (distSq < (phaseCanvas.width * phaseCanvas.width / 16)) {
                    phaseCtx.beginPath();
                    phaseCtx.moveTo(lastPhasePoint.x, lastPhasePoint.y);
                    phaseCtx.lineTo(px, py);
                    phaseCtx.strokeStyle = '#007bff';
                    phaseCtx.lineWidth = 1.5; // Slightly thicker for visibility
                    phaseCtx.stroke();
                }
            }

            // Update previous point for next frame
            lastPhasePoint = { x: px, y: py };
            
            // Labels (redraw to keep on top)
            phaseCtx.fillStyle = '#888';
            phaseCtx.font = '10px sans-serif';
            phaseCtx.fillText("+π", phaseCanvas.width - 20, phaseOriginY + 12);
            phaseCtx.fillText("-π", 5, phaseOriginY + 12);
        }

        // --- Main Loop ---
        function loop() {
            if (isRunning) {
                // High physics fidelity: multiple steps per frame
                for (let i = 0; i < 10; i++) {
                    rk4Step();
                }
            }
            drawSim();
            if (isRunning) drawPhase(); // Only update phase trail when running
            requestAnimationFrame(loop);
        }

        // --- Controls & UI Logic ---
        const playPauseBtn = document.getElementById('playPauseBtn');
        const clearPhaseBtn = document.getElementById('clearPhaseBtn');

        playPauseBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            playPauseBtn.textContent = isRunning ? 'Pause' : 'Resume';
            // Reset last point on pause/resume to prevent jumps
            lastPhasePoint = null; 
        });

        clearPhaseBtn.addEventListener('click', () => {
            phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);
            lastPhasePoint = null; // Reset trail
        });

        function updateParam(id, valDisplayId) {
            const slider = document.getElementById(id);
            const display = document.getElementById(valDisplayId);
            slider.addEventListener('input', () => {
                params[id] = parseFloat(slider.value);
                display.textContent = params[id].toFixed(2) + (id.includes('w') ? ' rad/s' : '');
                // Clear phase diagram and reset trail on param change
                phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);
                lastPhasePoint = null;
            });
        }

        updateParam('w0', 'val-w0');
        updateParam('w', 'val-w');
        updateParam('a', 'val-a');

        function resetSim(initialTheta) {
            state.theta = initialTheta;
            state.omega = 0;
            state.t = 0;
            
            // Sync UI
            document.getElementById('w0').value = params.w0; 
            document.getElementById('val-w0').textContent = params.w0.toFixed(2) + ' rad/s';
            document.getElementById('w').value = params.w; 
            document.getElementById('val-w').textContent = params.w.toFixed(2) + ' rad/s';
            document.getElementById('a').value = params.a; 
            document.getElementById('val-a').textContent = params.a.toFixed(2);

            phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);
            lastPhasePoint = null; // Reset trail
        }

        // --- Presets ---
        function setResonance() {
            params.w0 = 6.28;
            params.w = 6.28;
            params.a = 0.1;
            resetSim(0.1);
        }

        function setKapitza() {
            params.w0 = 6.28;
            params.w = 220; // High freq
            params.a = 0.05; 
            resetSim(Math.PI - 0.05); // Inverted start
        }

        function setChaos() {
            params.w0 = 6.28;
            params.w = 6.28;
            params.a = 1.25; // Chaotic regime
            resetSim(0.1);
        }

        // Start
        loop();

    </script>
</body>
</html>
